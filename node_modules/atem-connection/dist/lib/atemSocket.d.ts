import { EventEmitter } from 'eventemitter3';
import { ISerializableCommand, IDeserializedCommand } from '../commands';
export interface AtemSocketOptions {
    address: string;
    port: number;
    debugBuffers: boolean;
    disableMultithreaded: boolean;
    childProcessTimeout: number;
    maxPacketSize: number;
}
export type AtemSocketEvents = {
    disconnect: [];
    info: [string];
    debug: [string];
    error: [string];
    receivedCommands: [IDeserializedCommand[]];
    ackPackets: [number[]];
};
export declare class AtemSocket extends EventEmitter<AtemSocketEvents> {
    private readonly _debugBuffers;
    private readonly _disableMultithreaded;
    private readonly _childProcessTimeout;
    private readonly _maxPacketSize;
    private readonly _commandParser;
    private _nextPacketTrackingId;
    private _isDisconnecting;
    private _address;
    private _port;
    private _socketProcess;
    private _creatingSocket;
    private _exitUnsubscribe?;
    constructor(options: AtemSocketOptions);
    connect(address?: string, port?: number): Promise<void>;
    destroy(): Promise<void>;
    disconnect(): Promise<void>;
    get nextPacketTrackingId(): number;
    sendCommands(commands: Array<ISerializableCommand>): Promise<number[]>;
    private _createSocketProcess;
    private _parseCommands;
}
//# sourceMappingURL=atemSocket.d.ts.map