"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreadedClassManager = exports.ThreadedClassManagerInternal = exports.ThreadMode = exports.ThreadedClassManagerClassInternal = exports.childName = exports.ThreadedClassManagerClass = exports.RegisterExitHandlers = void 0;
const tslib_1 = require("tslib");
const sharedApi_1 = require("../shared/sharedApi");
const api_1 = require("../api");
const lib_1 = require("../shared/lib");
const webWorkers_1 = require("./workerPlatform/webWorkers");
const workerThreads_1 = require("./workerPlatform/workerThreads");
const childProcess_1 = require("./workerPlatform/childProcess");
const fakeWorker_1 = require("./workerPlatform/fakeWorker");
var RegisterExitHandlers;
(function (RegisterExitHandlers) {
    /**
     * Do a check if any exit handlers have been registered by someone else.
     * If not, will set up exit handlers to ensure child processes are killed on exit signal.
     */
    RegisterExitHandlers[RegisterExitHandlers["AUTO"] = -1] = "AUTO";
    /** Set up exit handlers to ensure child processes are killed on exit signal. */
    RegisterExitHandlers[RegisterExitHandlers["YES"] = 1] = "YES";
    /**
     * Don't set up any exit handlers (depending on your environment and Node version,
     * children might need to be manually killed).
     */
    RegisterExitHandlers[RegisterExitHandlers["NO"] = 0] = "NO";
})(RegisterExitHandlers = exports.RegisterExitHandlers || (exports.RegisterExitHandlers = {}));
class ThreadedClassManagerClass {
    constructor(internal) {
        this._internal = internal;
    }
    /** Enable debug messages */
    set debug(v) {
        this._internal.debug = v;
    }
    get debug() {
        return this._internal.debug;
    }
    /**
     * Enable strict mode.
     * When strict mode is enabled, checks will be done to ensure that best-practices are followed (such as listening to the proper events, etc).
     * Warnings will be output to the console if strict mode is enabled.
     */
    set strict(v) {
        this._internal.strict = v;
    }
    get strict() {
        return this._internal.strict;
    }
    /** Whether to register exit handlers. If not, then the application should ensure the threads are aborted on process exit */
    set handleExit(v) {
        this._internal.handleExit = v;
    }
    get handleExit() {
        return this._internal.handleExit;
    }
    /** Destroy a proxy class instance */
    destroy(proxy) {
        return this._internal.killProxy(proxy);
    }
    /** Destroys all proxy instances and closes all threads */
    destroyAll() {
        return this._internal.killAllChildren();
    }
    /** Returns the number of threads */
    getThreadCount() {
        return this._internal.getChildrenCount();
    }
    /** Returns memory usage for each thread */
    getThreadsMemoryUsage() {
        return this._internal.getMemoryUsage();
    }
    onEvent(proxy, event, cb) {
        return this._internal.onProxyEvent(proxy, event, cb);
    }
    /**
     * Restart the thread of the proxy instance
     * @param proxy
     * @param forceRestart If true, will kill the thread and restart it. If false, will only restart the thread if it is already dead.
     */
    restart(proxy, forceRestart) {
        return this._internal.restart(proxy, forceRestart);
    }
    /**
     * Returns a description of what threading mode the library will use in the current context.
     */
    getThreadMode() {
        if ((0, lib_1.isBrowser)()) {
            if ((0, lib_1.browserSupportsWebWorkers)()) {
                return ThreadMode.WEB_WORKER;
            }
            else {
                return ThreadMode.NOT_SUPPORTED;
            }
        }
        else {
            if ((0, lib_1.nodeSupportsWorkerThreads)()) {
                return ThreadMode.WORKER_THREADS;
            }
            else {
                return ThreadMode.CHILD_PROCESS;
            }
        }
    }
}
exports.ThreadedClassManagerClass = ThreadedClassManagerClass;
function childName(child) {
    return `Child_ ${Object.keys(child.instances).join(',')}`;
}
exports.childName = childName;
class ThreadedClassManagerClassInternal {
    constructor() {
        /** Set to true if you want to handle the exiting of child process yourselt */
        this.handleExit = RegisterExitHandlers.AUTO;
        this.isInitialized = false;
        this._threadId = 0;
        this._instanceId = 0;
        this._methodId = 0;
        this._children = {};
        this._pinging = true; // for testing only
        this.debug = false;
        this.strict = false;
        /** Pseudo-unique id to identify the parent ThreadedClass (for debugging) */
        this.uniqueId = Date.now() % 10000;
        /** Two-dimensional map, which maps Proxy -> event -> listener functions */
        this._proxyEventListeners = new Map();
        /** Contains a map of listeners, used to wait for a child to have been initialized */
        this._childInitializedListeners = new lib_1.ArrayMap();
    }
    findNextAvailableChild(config, pathToWorker) {
        this._init();
        let child = null;
        if (config.threadId) {
            child = this._children[config.threadId] || null;
        }
        else if (config.threadUsage) {
            child = this._findFreeChild(config.threadUsage);
        }
        if (!child) {
            // Create new child process:
            const newChild = {
                id: config.threadId || (`process_${this.uniqueId}_${this._threadId++}`),
                isNamed: !!config.threadId,
                pathToWorker: pathToWorker,
                process: this._createFork(config, pathToWorker),
                usage: config.threadUsage || 1,
                instances: {},
                methods: {},
                alive: true,
                isClosing: false,
                config,
                autoRestartFailCount: 0,
                autoRestartRetryTimeout: undefined,
                cmdId: 0,
                instanceMessageQueue: {},
                childMessageQueue: {},
                callbackId: 0,
                callbacks: {}
            };
            this._setupChildProcess(newChild);
            this._children[newChild.id] = newChild;
            child = newChild;
            if (this.debug)
                this.consoleLog(`New child: "${newChild.id}"`);
        }
        return child;
    }
    /**
     * Attach a proxy-instance to a child
     * @param child
     * @param proxy
     * @param onInstanceMessage
     */
    attachInstanceToChild(config, child, proxy, pathToModule, exportName, constructorArgs, onInstanceMessage) {
        const instance = {
            id: `instance_${this.uniqueId}_${this._instanceId++}` + (config.instanceName ? `_${config.instanceName}` : ''),
            child: child,
            proxy: proxy,
            usage: config.threadUsage,
            freezeLimit: config.freezeLimit,
            onMessageCallback: onInstanceMessage,
            pathToModule: pathToModule,
            exportName: exportName,
            constructorArgs: constructorArgs,
            initialized: false,
            config: config
        };
        child.instances[instance.id] = instance;
        if (this.debug)
            this.consoleLog(`Add instance "${instance.id}" to "${child.id}"`);
        return instance;
    }
    killProxy(proxy) {
        return new Promise((resolve, reject) => {
            let foundProxy = false;
            for (const childId of Object.keys(this._children)) {
                const child = this._children[childId];
                const instanceId = this.findProxyInstanceOfChild(child, proxy);
                if (instanceId) {
                    let instance = child.instances[instanceId];
                    foundProxy = true;
                    if (Object.keys(child.instances).length === 1) {
                        // if there is only one instance left, we can kill the child
                        this.killChild(childId, 'no instances left')
                            .then(resolve)
                            .catch(reject);
                    }
                    else {
                        const cleanup = () => {
                            delete child.instances[instanceId];
                        };
                        this.sendMessageToInstance(instance, {
                            cmd: sharedApi_1.Message.To.Instance.CommandType.KILL
                        }, () => {
                            cleanup();
                            resolve();
                        });
                        setTimeout(() => {
                            cleanup();
                            reject('Timeout: Kill child instance');
                        }, 1000);
                        if (instance.usage) {
                            child.usage -= instance.usage;
                        }
                    }
                    break;
                }
            }
            if (!foundProxy) {
                reject('killProxy: Proxy not found');
            }
        });
    }
    sendMessageToInstance(instance, messageConstr, cb) {
        try {
            if (!instance.child)
                throw new Error(`Instance ${instance.id} has been detached from child process`);
            if (!instance.child.alive)
                throw new Error(`Child process of instance ${instance.id} has been closed`);
            if (instance.child.isClosing)
                throw new Error(`Child process of instance ${instance.id} is closing`);
            const message = Object.assign(Object.assign({}, messageConstr), {
                messageType: 'instance',
                cmdId: instance.child.cmdId++,
                instanceId: instance.id
            });
            if (message.cmd !== sharedApi_1.Message.To.Instance.CommandType.INIT &&
                !instance.initialized)
                throw Error(`Child instance ${instance.id} is not initialized`);
            if (cb)
                instance.child.instanceMessageQueue[message.cmdId + ''] = cb;
            try {
                instance.child.process.send(message);
            }
            catch (e) {
                delete instance.child.instanceMessageQueue[message.cmdId + ''];
                if ((e.toString() || '').match(/circular structure/)) { // TypeError: Converting circular structure to JSON
                    throw new Error(`Unsupported attribute (circular structure) in instance ${instance.id}: ` + e.toString());
                }
                else {
                    throw e;
                }
            }
        }
        catch (e) {
            if (cb)
                cb(instance, (e.stack || e).toString());
            else
                throw e;
        }
    }
    sendMessageToChild(child, messageConstr, cb) {
        try {
            if (!child.alive)
                throw new Error(`Child process ${child.id} has been closed`);
            if (child.isClosing)
                throw new Error(`Child process  ${child.id} is closing`);
            const message = Object.assign(Object.assign({}, messageConstr), {
                messageType: 'child',
                cmdId: child.cmdId++
            });
            if (cb)
                child.childMessageQueue[message.cmdId + ''] = cb;
            try {
                child.process.send(message);
            }
            catch (e) {
                delete child.childMessageQueue[message.cmdId + ''];
                if ((e.toString() || '').match(/circular structure/)) { // TypeError: Converting circular structure to JSON
                    throw new Error(`Unsupported attribute (circular structure) in child ${child.id}: ` + e.toString());
                }
                else {
                    throw e;
                }
            }
        }
        catch (e) {
            if (cb)
                cb((e.stack || e).toString());
            else
                throw e;
        }
    }
    getChildrenCount() {
        return Object.keys(this._children).length;
    }
    getMemoryUsage() {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            const memUsage = {};
            yield Promise.all(Object.keys(this._children).map((childId) => {
                return new Promise((resolve) => {
                    const child = this._children[childId];
                    this.sendMessageToChild(child, {
                        cmd: sharedApi_1.Message.To.Child.CommandType.GET_MEM_USAGE
                    }, (err, result0) => {
                        const result = result0 && (0, sharedApi_1.decodeArguments)(() => null, [result0], () => (() => Promise.resolve()))[0];
                        const o = Object.assign(Object.assign({}, (err ?
                            { error: err.toString() } :
                            result ?
                                result :
                                { error: 'unknown' })), { description: this.getChildDescriptor(child) });
                        memUsage[childId] = o;
                        resolve();
                    });
                });
            }));
            return memUsage;
        });
    }
    killAllChildren() {
        return Promise.all(Object.keys(this._children).map((id) => {
            const child = this._children[id];
            if (this.debug)
                this.consoleLog(`Killing child "${this.getChildDescriptor(child)}"`);
            return this.killChild(id, 'killAllChildren');
        })).then(() => {
            return;
        });
    }
    /** Restart the thread of a proxy instance */
    restart(proxy, forceRestart) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            let foundInstance;
            let foundChild;
            for (const child of Object.values(this._children)) {
                const foundInstanceId = this.findProxyInstanceOfChild(child, proxy);
                if (foundInstanceId) {
                    foundInstance = child.instances[foundInstanceId];
                    foundChild = child;
                    break;
                }
            }
            if (!foundChild)
                throw Error(`Child of proxy not found`);
            if (!foundInstance)
                throw Error(`Instance of proxy not found`);
            yield this.restartChild(foundChild, [foundInstance], forceRestart);
        });
    }
    restartChild(child, onlyInstances, forceRestart) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function* () {
            if (child.alive && forceRestart) {
                yield this.killChild(child, 'restart child', false);
            }
            this.clearRestartTimeout(child);
            if (!child.alive) {
                // clear old process:
                child.process.removeAllListeners();
                // delete child.process
                Object.keys(child.instances).forEach((instanceId) => {
                    const instance = child.instances[instanceId];
                    instance.initialized = false;
                });
                // start new process
                child.alive = true;
                child.isClosing = false;
                child.process = this._createFork(child.config, child.pathToWorker);
                this._setupChildProcess(child);
            }
            let p = new Promise((resolve, reject) => {
                var _a;
                let timeout;
                if (child.config.restartTimeout !== 0) {
                    const restartTimeout = (_a = child.config.restartTimeout) !== null && _a !== void 0 ? _a : sharedApi_1.DEFAULT_RESTART_TIMEOUT;
                    timeout = setTimeout(() => {
                        reject(new api_1.RestartTimeoutError(`Timeout when trying to restart after ${restartTimeout}`));
                        // Remove listener:
                        this._childInitializedListeners.remove(child.id, onInit);
                    }, restartTimeout);
                }
                const onInit = () => {
                    if (timeout)
                        clearTimeout(timeout);
                    resolve();
                    // Remove listener:
                    this._childInitializedListeners.remove(child.id, onInit);
                };
                this._childInitializedListeners.push(child.id, onInit);
            });
            const promises = [p];
            let instances = (onlyInstances ||
                Object.keys(child.instances).map((instanceId) => {
                    return child.instances[instanceId];
                }));
            instances.forEach((instance) => {
                promises.push(new Promise((resolve, reject) => {
                    this.sendInit(child, instance, instance.config, (_instance, err) => {
                        // no need to do anything, the proxy is already initialized from earlier
                        if (err) {
                            reject(err);
                        }
                        else {
                            resolve();
                        }
                        return true;
                    });
                }));
            });
            yield Promise.all(promises);
        });
    }
    canRetryRestart(child) {
        var _a;
        const autoRestartRetryCount = (_a = child.config.autoRestartRetryCount) !== null && _a !== void 0 ? _a : sharedApi_1.DEFAULT_AUTO_RESTART_RETRY_COUNT;
        if (autoRestartRetryCount === 0)
            return true; // restart indefinitely
        return child.autoRestartFailCount < autoRestartRetryCount;
    }
    sendInit(child, instance, config, cb) {
        let encodedArgs = (0, sharedApi_1.encodeArguments)(instance, instance.child.callbacks, instance.constructorArgs, !!config.disableMultithreading);
        let msg = {
            cmd: sharedApi_1.Message.To.Instance.CommandType.INIT,
            modulePath: instance.pathToModule,
            exportName: instance.exportName,
            args: encodedArgs,
            config: config,
            parentPid: process.pid
        };
        instance.initialized = true;
        exports.ThreadedClassManagerInternal.sendMessageToInstance(instance, msg, (instance, e, initProps) => {
            if (!cb ||
                cb(instance, e, initProps)) {
                // Notify listeners that the instance is initialized:
                const listeners = this._childInitializedListeners.get(child.id);
                if (listeners) {
                    for (const listener of listeners) {
                        listener();
                    }
                }
            }
        });
    }
    startMonitoringChild(instance) {
        var _a;
        const pingTime = (_a = instance.freezeLimit) !== null && _a !== void 0 ? _a : sharedApi_1.DEFAULT_CHILD_FREEZE_TIME;
        if (pingTime === 0)
            return; // 0 disables the monitoring
        const monitorChild = () => {
            if (instance.child && instance.child.alive && this._pinging) {
                this._pingChild(instance, pingTime)
                    .then(() => {
                    // ping successful
                    // ping again later:
                    setTimeout(() => {
                        monitorChild();
                    }, pingTime);
                })
                    .catch(() => {
                    // Ping failed
                    if (instance.child &&
                        instance.child.alive &&
                        !instance.child.isClosing) {
                        // this.consoleLog(`Ping failed for Child "${instance.child.id }" of instance "${instance.id}"`)
                        this._childHasCrashed(instance.child, `Child process ("${this.getChildDescriptor(instance.child)}") of instance ${instance.id} ping timeout`);
                    }
                });
            }
        };
        setTimeout(() => {
            monitorChild();
        }, pingTime);
    }
    doMethod(child, methodName, cb) {
        // Return a promise that will execute the callback cb
        // but also put the promise in child.methods, so that the promise can be aborted
        // in the case of a child crash
        const methodId = 'm' + this._methodId++;
        const p = new Promise((resolve, reject) => {
            child.methods[methodId] = { methodName, resolve, reject };
            cb(resolve, reject);
        })
            .then((result) => {
            delete child.methods[methodId];
            return result;
        })
            .catch((error) => {
            delete child.methods[methodId];
            throw error;
        });
        return p;
    }
    getChildDescriptor(child) {
        return `${child.id} (${Object.keys(child.instances).join(', ')})`;
    }
    checkInstance(instance, errStack) {
        if (!this.strict)
            return;
        const getStack = () => {
            // strip first 2 lines of the stack:
            return `${errStack.stack}`.split('\n').slice(2).join('\n');
        };
        // Wait a little bit, to allow for the events to have been set up asynchronously in user-land:
        setTimeout(() => {
            // Ensure that error events are set up:
            const events = this._proxyEventListeners.get(instance.proxy);
            if (!events || events.arraySize('error') === 0) {
                this.consoleLog(`Warning: No listener for the 'error' event was registered,
Solve this by adding
ThreadedClassManager.onEvent(instance, 'error', (error) => {})
${getStack()}`);
            }
            if (!events || events.arraySize('warning') === 0) {
                this.consoleLog(`Warning: No listener for the 'warning' event was registered,
Solve this by adding
ThreadedClassManager.onEvent(instance, 'warning', (warning) => {})
${getStack()}`);
            }
            if (!instance.config.autoRestart) {
                if (!events || events.arraySize('thread_closed') === 0) {
                    this.consoleLog(`Warning: autoRestart is disabled and no listener for the 'thread_closed' event was registered.
Solve this by either set {autoRestart: true} in threadedClass() options, or set up an event listener to handle a restart:
use ThreadedClassManager.onEvent(instance, 'thread_closed', () => {})
at ${getStack()}`);
                }
            }
            else {
                if (!events || events.arraySize('restarted') === 0) {
                    this.consoleLog(`Warning: No listener for the 'restarted' event was registered.
It is recommended to set up an event listener for this, so you are aware of that an instance has been restarted:
use ThreadedClassManager.onEvent(instance, 'restarted', () => {})
${getStack()}`);
                }
            }
        }, 1);
    }
    onProxyEvent(proxy, event, cb) {
        let events = this._proxyEventListeners.get(proxy);
        if (!events)
            events = new lib_1.ArrayMap();
        events.push(event, cb);
        // Save changes:
        this._proxyEventListeners.set(proxy, events);
        return {
            stop: () => {
                const events = this._proxyEventListeners.get(proxy);
                if (!events)
                    return;
                events.remove(event, cb);
                // Save changes:
                if (events.size > 0) {
                    this._proxyEventListeners.set(proxy, events);
                }
                else {
                    this._proxyEventListeners.delete(proxy);
                }
            }
        };
    }
    _emitProxyEvent(child, event, ...args) {
        for (const instance of Object.values(child.instances)) {
            const events = this._proxyEventListeners.get(instance.proxy);
            if (events) {
                const listeners = events.get(event);
                if (listeners) {
                    for (const listener of listeners) {
                        try {
                            listener(...args);
                        }
                        catch (err) {
                            this.consoleLog(`Error in event listener for "${event}":`, err);
                        }
                    }
                }
            }
        }
    }
    /** Called before using internally */
    _init() {
        if (!this.isInitialized &&
            !(0, lib_1.isBrowser)() // in NodeJS
        ) {
            let registerExitHandlers;
            switch (this.handleExit) {
                case RegisterExitHandlers.YES:
                    registerExitHandlers = true;
                    break;
                case RegisterExitHandlers.AUTO:
                    if (process.listenerCount('exit') === 0 || process.listenerCount('uncaughtException') === 0 || process.listenerCount('unhandledRejection') === 0) {
                        this.consoleLog('Skipping exit handler registration as no exit handler is registered');
                        // If no listeners are registered,
                        // we don't want to change the default Node behaviours upon those signals
                        registerExitHandlers = false;
                    }
                    else {
                        registerExitHandlers = true;
                    }
                    break;
                default: // RegisterExitHandlers.NO
                    registerExitHandlers = false;
            }
            if (registerExitHandlers) {
                // Close the child processes upon exit:
                process.stdin.resume(); // so the program will not close instantly
                // Read about Node signals here:
                // https://nodejs.org/api/process.html#process_signal_events
                const onSignal = (signal, message) => {
                    let msg = `Signal "${signal}" event`;
                    if (message)
                        msg += ', ' + message;
                    if (process.listenerCount(signal) === 1) {
                        // If there is only one listener, that's us
                        // Log the error, it is the right thing to do.
                        console.error(msg);
                    }
                    else {
                        if (this.debug)
                            this.consoleLog(msg);
                    }
                    this.killAllChildren()
                        .catch(this.consoleError);
                    process.exit();
                };
                // Do something when app is closing:
                process.on('exit', (code) => onSignal('exit', `exit code: ${code}`));
                // catches ctrl+c event
                process.on('SIGINT', () => onSignal('SIGINT'));
                // Terminal windows closed
                process.on('SIGHUP', () => onSignal('SIGHUP'));
                process.on('SIGTERM', () => onSignal('SIGTERM'));
                // SIGKILL cannot have a listener attached
                // SIGSTOP cannot have a listener attached
                // catches "kill pid" (for example: nodemon restart)
                process.on('SIGUSR1', () => onSignal('SIGUSR1'));
                process.on('SIGUSR2', () => onSignal('SIGUSR2'));
                // catches uncaught exceptions
                process.on('uncaughtException', (message) => onSignal('uncaughtException', message.toString()));
                process.on('unhandledRejection', (message) => onSignal('unhandledRejection', message ? message.toString() : undefined));
            }
        }
        this.isInitialized = true;
    }
    _pingChild(instance, timeoutTime) {
        return new Promise((resolve, reject) => {
            let msg = {
                cmd: sharedApi_1.Message.To.Instance.CommandType.PING
            };
            const timeout = setTimeout(() => {
                reject(); // timeout
            }, timeoutTime);
            exports.ThreadedClassManagerInternal.sendMessageToInstance(instance, msg, (_instance, err) => {
                clearTimeout(timeout);
                if (!err) {
                    resolve();
                }
                else {
                    this.consoleError(err);
                    reject(err);
                }
            });
        });
    }
    _childHasCrashed(child, reason) {
        // Called whenever a fatal error with a child has been discovered
        this.rejectChildMethods(child, reason);
        if (!child.isClosing) {
            let shouldRestart = false;
            const restartInstances = [];
            Object.keys(child.instances).forEach((instanceId) => {
                const instance = child.instances[instanceId];
                if (instance.config.autoRestart) {
                    shouldRestart = true;
                    restartInstances.push(instance);
                }
            });
            if (shouldRestart) {
                this.restartChild(child, restartInstances, true)
                    .then(() => {
                    child.autoRestartFailCount = 0;
                    this._emitProxyEvent(child, 'restarted');
                })
                    .catch((err) => {
                    // The restart failed
                    child.autoRestartFailCount++;
                    // Try to restart it again:
                    if (this.canRetryRestart(child)) {
                        this._emitProxyEvent(child, 'warning', `Error when restarting child, trying again... Original error: ${err}`);
                        // Kill the child, so we can to restart it later:
                        this.killChild(child, 'error when restarting', false)
                            .catch((e) => {
                            this.consoleError(`Could not kill child: "${child.id}"`, e);
                        })
                            .then(() => {
                            var _a;
                            const autoRestartRetryDelay = (_a = child.config.autoRestartRetryDelay) !== null && _a !== void 0 ? _a : sharedApi_1.DEFAULT_AUTO_RESTART_RETRY_DELAY;
                            child.autoRestartRetryTimeout = setTimeout(() => {
                                this._childHasCrashed(child, `restart failed`);
                            }, autoRestartRetryDelay);
                        })
                            .catch((e) => {
                            this.consoleError(`Unknown error: "${child.id}"`, e);
                        });
                    }
                    else {
                        this._emitProxyEvent(child, 'error', err);
                        if (this.debug)
                            this.consoleError('Error when running restartChild()', err);
                        // Clean up the child:
                        this.killChild(child, 'timeout when restarting', true).catch((e) => {
                            this.consoleError(`Could not kill child: "${child.id}"`, e);
                        });
                    }
                });
            }
            else {
                // No instance wants to be restarted, make sure the child is killed then:
                if (child.alive) {
                    this.killChild(child, `child has crashed (${reason})`, false)
                        .catch((err) => {
                        this._emitProxyEvent(child, 'error', err);
                        if (this.debug)
                            this.consoleError('Error when running killChild()', err);
                    });
                }
            }
        }
    }
    clearRestartTimeout(child) {
        if (child.autoRestartRetryTimeout !== undefined) {
            clearTimeout(child.autoRestartRetryTimeout);
            child.autoRestartRetryTimeout = undefined;
        }
    }
    _createFork(config, pathToWorker) {
        if (config.disableMultithreading) {
            return new fakeWorker_1.FakeProcess();
        }
        else {
            if ((0, lib_1.isBrowser)()) {
                return (0, webWorkers_1.forkWebWorker)(pathToWorker);
            }
            else {
                // in NodeJS
                if ((0, lib_1.nodeSupportsWorkerThreads)()) {
                    return (0, workerThreads_1.forkWorkerThread)(pathToWorker);
                }
                else {
                    return (0, childProcess_1.forkChildProcess)(pathToWorker);
                }
            }
        }
    }
    _setupChildProcess(child) {
        child.process.on('close', () => {
            if (child.alive) {
                child.alive = false;
                this._emitProxyEvent(child, 'thread_closed');
                this._childHasCrashed(child, `Child process "${childName(child)}" was closed`);
            }
        });
        child.process.on('error', (err) => {
            this._emitProxyEvent(child, 'error', err);
            if (this.debug)
                this.consoleError('Error from child ' + child.id, err);
        });
        child.process.on('message', (message) => {
            if (message.messageType === 'child') {
                try {
                    this._onMessageFromChild(child, message);
                }
                catch (e) {
                    if (this.debug)
                        this.consoleError(`Error in onMessageCallback in child ${child.id}`, message, e);
                    throw e;
                }
            }
            else if (message.messageType === 'instance') {
                const instance = child.instances[message.instanceId];
                if (instance) {
                    try {
                        instance.onMessageCallback(instance, message);
                    }
                    catch (e) {
                        if (this.debug)
                            this.consoleError(`Error in onMessageCallback in instance ${instance.id}`, message, instance, e);
                        throw e;
                    }
                }
                else {
                    const err = new Error(`Instance "${message.instanceId}" not found. Received message "${message.messageType}" from child "${child.id}", "${childName(child)}"`);
                    this._emitProxyEvent(child, 'error', err);
                    if (this.debug)
                        this.consoleError(err);
                }
            }
            else {
                const err = new Error(`Unknown messageType "${message['messageType']}"!`);
                this._emitProxyEvent(child, 'error', err);
                if (this.debug)
                    this.consoleError(err);
            }
        });
    }
    _onMessageFromChild(child, message) {
        if (message.cmd === sharedApi_1.Message.From.Child.CommandType.LOG) {
            console.log(child.id, ...message.log);
        }
        else if (message.cmd === sharedApi_1.Message.From.Child.CommandType.REPLY) {
            let msg = message;
            let cb = child.childMessageQueue[msg.replyTo + ''];
            if (!cb)
                return;
            if (msg.error) {
                cb(msg.error);
            }
            else {
                cb(null, msg.reply);
            }
            delete child.instanceMessageQueue[msg.replyTo + ''];
        }
        else if (message.cmd === sharedApi_1.Message.From.Child.CommandType.CALLBACK) {
            // Callback function is called by worker
            let msg = message;
            let callback = child.callbacks[msg.callbackId];
            if (callback) {
                try {
                    Promise.resolve(callback(...msg.args))
                        .then((result) => {
                        let encodedResult = (0, sharedApi_1.encodeArguments)({}, child.callbacks, [result], !!child.process.isFakeProcess);
                        this._sendReplyToChild(child, msg.cmdId, undefined, encodedResult[0]);
                    })
                        .catch((err) => {
                        this._replyErrorToChild(child, msg, err);
                    });
                }
                catch (err) {
                    this._replyErrorToChild(child, msg, err);
                }
            }
            else
                throw Error(`callback "${msg.callbackId}" not found in child ${child.id}`);
        }
    }
    _replyErrorToChild(child, messageToReplyTo, error) {
        this._sendReplyToChild(child, messageToReplyTo.cmdId, error);
    }
    _sendReplyToChild(child, replyTo, error, reply, cb) {
        let msg = {
            cmd: sharedApi_1.Message.To.Child.CommandType.REPLY,
            replyTo: replyTo,
            reply: reply,
            error: error ? (error.stack || error).toString() : error
        };
        this.sendMessageToChild(child, msg, cb);
    }
    _findFreeChild(threadUsage) {
        let id = Object.keys(this._children).find((id) => {
            const child = this._children[id];
            if (!child.isNamed &&
                child.usage + threadUsage <= 1) {
                return true;
            }
            return false;
        });
        if (id) {
            const child = this._children[id];
            child.usage += threadUsage;
            return child;
        }
        return null;
    }
    killChild(idOrChild, reason, cleanUp = true) {
        return new Promise((resolve, reject) => {
            var _a;
            let child;
            if (typeof idOrChild === 'string') {
                const id = idOrChild;
                child = this._children[id];
                if (!child) {
                    reject(`killChild: Child ${id} not found`);
                    return;
                }
            }
            else {
                child = idOrChild;
            }
            if (this.debug)
                this.consoleLog(`Killing child ${child.id} due to: ${reason}`);
            if (child) {
                if (cleanUp) {
                    this.clearRestartTimeout(child);
                }
                if (!child.alive) {
                    if (cleanUp) {
                        delete this._children[child.id];
                    }
                    child.isClosing = false;
                    resolve();
                }
                else {
                    let timeout;
                    const killTimeout = (_a = child.config.killTimeout) !== null && _a !== void 0 ? _a : sharedApi_1.DEFAULT_KILL_TIMEOUT;
                    if (killTimeout !== 0) {
                        timeout = setTimeout(() => {
                            if (cleanUp) {
                                delete this._children[child.id];
                            }
                            reject(new api_1.KillTimeoutError(`Timeout: Kill child process "${child.id}"`));
                        }, killTimeout);
                    }
                    child.process.once('close', () => {
                        if (cleanUp) {
                            // Clean up:
                            Object.entries(child.instances).forEach(([instanceId, instance]) => {
                                // const instance = child.instances[instanceId]
                                // delete instance.child
                                delete child.instances[instanceId];
                                const events = this._proxyEventListeners.get(instance.proxy);
                                events === null || events === void 0 ? void 0 : events.clear();
                                this._proxyEventListeners.delete(instance.proxy);
                            });
                            delete this._children[child.id];
                        }
                        if (timeout) {
                            clearTimeout(timeout);
                        }
                        child.isClosing = false;
                        resolve();
                    });
                    if (!child.isClosing) {
                        child.isClosing = true;
                        child.process.kill();
                    }
                }
            }
        });
    }
    rejectChildMethods(child, reason) {
        Object.keys(child.methods).forEach((methodId) => {
            const method = child.methods[methodId];
            method.reject(Error(`Method "${method.methodName}()" aborted due to: ${reason}`));
        });
        child.methods = {};
    }
    /** trace to console.error */
    consoleError(...args) {
        console.error(`ThreadedClass Error (${this.uniqueId})`, ...args);
    }
    /** trace to console.log */
    consoleLog(...args) {
        console.log(`ThreadedClass (${this.uniqueId})`, ...args);
    }
    /** Look up which instance contains a proxy, and return its instanceId */
    findProxyInstanceOfChild(child, proxy) {
        for (const instanceId of Object.keys(child.instances)) {
            let instance = child.instances[instanceId];
            if (instance.proxy === proxy)
                return instanceId;
        }
        return undefined;
    }
}
exports.ThreadedClassManagerClassInternal = ThreadedClassManagerClassInternal;
var ThreadMode;
(function (ThreadMode) {
    /** Web-workers, in browser */
    ThreadMode["WEB_WORKER"] = "web_worker";
    /** Nothing, Web-workers not supported */
    ThreadMode["NOT_SUPPORTED"] = "not_supported";
    /** Worker threads */
    ThreadMode["WORKER_THREADS"] = "worker_threads";
    /** Child process */
    ThreadMode["CHILD_PROCESS"] = "child_process";
})(ThreadMode = exports.ThreadMode || (exports.ThreadMode = {}));
// Singleton:
exports.ThreadedClassManagerInternal = new ThreadedClassManagerClassInternal();
exports.ThreadedClassManager = new ThreadedClassManagerClass(exports.ThreadedClassManagerInternal);
//# sourceMappingURL=manager.js.map