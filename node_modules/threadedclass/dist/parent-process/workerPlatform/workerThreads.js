"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forkWorkerThread = exports.WorkerThread = void 0;
const lib_1 = require("../../shared/lib");
const _base_1 = require("./_base");
const fs_1 = require("fs");
const path = require("path");
const WorkerThreads = (0, lib_1.getWorkerThreads)();
const DEFAULT_ELECTRON_LOADER = path.join(__dirname, '../../js/asar-loader.js');
let needsCustomElectronLoader = false;
const electronVersion = process.versions.electron;
if (electronVersion && DEFAULT_ELECTRON_LOADER.match(/.asar(\/|\\)/)) {
    // we are running in electron and from inside an asar file
    // electron versions below 17.3 need this manual loader
    const [major, minor] = electronVersion.split('.').map((x) => parseInt(x, 10));
    if (major < 17 || (major === 17 && minor < 3)) {
        needsCustomElectronLoader = true;
    }
}
/** Functions for spawning worker-threads in NodeJS */
class WorkerThread extends _base_1.WorkerPlatformBase {
    constructor(pathToWorker) {
        super();
        // @ts-ignore
        // this.worker = new window.Worker(pathToWorker)
        if (!WorkerThreads)
            throw new Error('Unable to create Worker thread! Not supported!');
        // Figure out the loader to use. This is to allow for some environment setup (eg require behaviour modification) before trying to run threadedClass
        let loader = process.env.THREADEDCLASS_WORKERTHREAD_LOADER;
        if (!loader && needsCustomElectronLoader) {
            loader = DEFAULT_ELECTRON_LOADER;
        }
        if (loader) {
            // The WorkerThreads may will not be able to load this file, so we must do it in the parent
            const buf = (0, fs_1.readFileSync)(loader);
            // Start the WorkerThread, passing pathToWorker so that the loader knows what it should execute
            this.worker = new WorkerThreads.Worker(buf.toString(), {
                workerData: pathToWorker,
                eval: true
            });
        }
        else {
            // No loader, so run the worker directly
            this.worker = new WorkerThreads.Worker(pathToWorker, {
                workerData: ''
            });
        }
        this.worker.on('message', (message) => {
            this.emit('message', message);
            // if (message.type === 'message') {
            // } else console.log('unknown message type', message)
        });
        this.worker.on('messageerror', (error) => {
            this.emit('error', error);
        });
        this.worker.on('error', (error) => {
            this.emit('error', error);
        });
        this.worker.on('exit', (_code) => {
            this.emit('close');
        });
        this.worker.on('close', () => {
            this.emit('close');
        });
    }
    kill() {
        const p = this.worker.terminate();
        if (p) {
            p.then(() => {
                this.emit('close');
            }).catch((err) => {
                console.error('Worker Thread terminate failed', err);
            });
        }
        else {
            // If it didnt return a promise, then it as a blocking operation
            this.emit('close');
        }
    }
    send(message) {
        this.worker.postMessage(message);
    }
}
exports.WorkerThread = WorkerThread;
function forkWorkerThread(pathToWorker) {
    return new WorkerThread(pathToWorker);
}
exports.forkWorkerThread = forkWorkerThread;
//# sourceMappingURL=workerThreads.js.map