"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeArguments = exports.encodeArguments = exports.Message = exports.InitPropType = exports.DEFAULT_AUTO_RESTART_RETRY_DELAY = exports.DEFAULT_AUTO_RESTART_RETRY_COUNT = exports.DEFAULT_KILL_TIMEOUT = exports.DEFAULT_RESTART_TIMEOUT = exports.DEFAULT_CHILD_FREEZE_TIME = void 0;
// This file contains definitions for the API between the child and parent process.
exports.DEFAULT_CHILD_FREEZE_TIME = 1000; // how long to wait before considering a child to be unresponsive
exports.DEFAULT_RESTART_TIMEOUT = 1000; // how long to wait for the child to come back after restart
exports.DEFAULT_KILL_TIMEOUT = 1000; // how long to wait for the thread to close when terminating it
exports.DEFAULT_AUTO_RESTART_RETRY_COUNT = 1; // after how many failed restarts to give up
exports.DEFAULT_AUTO_RESTART_RETRY_DELAY = 1000; // how long to wait before retrying a failed restart
var InitPropType;
(function (InitPropType) {
    InitPropType["FUNCTION"] = "function";
    InitPropType["VALUE"] = "value";
})(InitPropType = exports.InitPropType || (exports.InitPropType = {}));
// Messages to/from child instances ------------------------------------------------
/** Definitions of all messages between the child and parent */
var Message;
(function (Message) {
    /** Containes definitions of messages sent from the parent process */
    let To;
    (function (To) {
        /** Defines messages sent from the parent process to the child instance */
        let Instance;
        (function (Instance) {
            let CommandType;
            (function (CommandType) {
                CommandType["INIT"] = "init";
                CommandType["PING"] = "ping";
                CommandType["FUNCTION"] = "fcn";
                CommandType["REPLY"] = "reply";
                CommandType["SET"] = "set";
                CommandType["KILL"] = "kill";
                CommandType["CALLBACK"] = "callback";
            })(CommandType = Instance.CommandType || (Instance.CommandType = {}));
        })(Instance = To.Instance || (To.Instance = {}));
        /** Defines messages sent from the parent process to the child process */
        let Child;
        (function (Child) {
            let CommandType;
            (function (CommandType) {
                CommandType["GET_MEM_USAGE"] = "get_mem_usage";
                CommandType["REPLY"] = "reply";
            })(CommandType = Child.CommandType || (Child.CommandType = {}));
        })(Child = To.Child || (To.Child = {}));
    })(To = Message.To || (Message.To = {}));
    /** Containes definitions of messages sent from the child process */
    let From;
    (function (From) {
        /** Defines messages sent from the child instance to the parent process */
        let Instance;
        (function (Instance) {
            let CommandType;
            (function (CommandType) {
                CommandType["CALLBACK"] = "callback";
                CommandType["REPLY"] = "reply";
            })(CommandType = Instance.CommandType || (Instance.CommandType = {}));
        })(Instance = From.Instance || (From.Instance = {}));
        /** Defines messages sent from the child process to the parent process */
        let Child;
        (function (Child) {
            let CommandType;
            (function (CommandType) {
                CommandType["LOG"] = "log";
                CommandType["REPLY"] = "reply";
                CommandType["CALLBACK"] = "callback";
            })(CommandType = Child.CommandType || (Child.CommandType = {}));
        })(Child = From.Child || (From.Child = {}));
    })(From = Message.From || (Message.From = {}));
})(Message = exports.Message || (exports.Message = {}));
var ArgumentType;
(function (ArgumentType) {
    ArgumentType["STRING"] = "string";
    ArgumentType["NUMBER"] = "number";
    ArgumentType["UNDEFINED"] = "undefined";
    ArgumentType["NULL"] = "null";
    ArgumentType["OBJECT"] = "object";
    ArgumentType["FUNCTION"] = "function";
    ArgumentType["BUFFER"] = "buffer";
    ArgumentType["OTHER"] = "other";
})(ArgumentType || (ArgumentType = {}));
let argumentsCallbackId = 0;
function encodeArguments(instance, callbacks, args, disabledMultithreading) {
    try {
        return args.map((arg, i) => {
            try {
                if (typeof arg === 'object' && arg === instance) {
                    return { type: ArgumentType.OBJECT, value: 'self' };
                }
                if (disabledMultithreading) {
                    // In single-threaded mode, we can send the arguments directly, without any conversion:
                    if (arg instanceof Buffer)
                        return { type: ArgumentType.BUFFER, original: arg, value: null };
                    if (typeof arg === 'object')
                        return { type: ArgumentType.OBJECT, original: arg, value: null };
                }
                if (arg instanceof Buffer)
                    return { type: ArgumentType.BUFFER, value: arg.toString('hex') };
                if (typeof arg === 'string')
                    return { type: ArgumentType.STRING, value: arg };
                if (typeof arg === 'number')
                    return { type: ArgumentType.NUMBER, value: arg };
                if (typeof arg === 'function') {
                    // have we seen this one before?
                    for (const id in callbacks) {
                        if (callbacks[id] === arg) {
                            return { type: ArgumentType.FUNCTION, value: id + '' };
                        }
                    }
                    // new function, so add it to our list
                    const callbackId = argumentsCallbackId++;
                    callbacks[callbackId + ''] = arg;
                    return { type: ArgumentType.FUNCTION, value: callbackId + '' };
                }
                if (arg === undefined)
                    return { type: ArgumentType.UNDEFINED, value: arg };
                if (arg === null)
                    return { type: ArgumentType.NULL, value: arg };
                if (typeof arg === 'object')
                    return { type: ArgumentType.OBJECT, value: arg };
                return { type: ArgumentType.OTHER, value: arg };
            }
            catch (e) {
                if (e.stack)
                    e.stack += '\nIn encodeArguments, argument ' + i;
                throw e;
            }
        });
    }
    catch (e) {
        if (e.stack)
            e.stack += '\nThreadedClass, unsupported attribute';
        throw e;
    }
}
exports.encodeArguments = encodeArguments;
function decodeArguments(instance, args, getCallback) {
    // Go through arguments and de-serialize them
    return args.map((a) => {
        if (a.original !== undefined)
            return a.original;
        if (a.type === ArgumentType.STRING)
            return a.value;
        if (a.type === ArgumentType.NUMBER)
            return a.value;
        if (a.type === ArgumentType.BUFFER)
            return Buffer.from(a.value, 'hex');
        if (a.type === ArgumentType.UNDEFINED)
            return a.value;
        if (a.type === ArgumentType.NULL)
            return a.value;
        if (a.type === ArgumentType.FUNCTION) {
            return getCallback(a);
        }
        if (a.type === ArgumentType.OBJECT) {
            if (a.value === 'self') {
                return instance();
            }
            else {
                return a.value;
            }
        }
        return a.value;
    });
}
exports.decodeArguments = decodeArguments;
//# sourceMappingURL=sharedApi.js.map