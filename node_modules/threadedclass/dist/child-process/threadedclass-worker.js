"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lib_1 = require("../shared/lib");
const worker_1 = require("./worker");
const WorkerThreads = (0, lib_1.getWorkerThreads)();
// This file is launched in the worker child process.
// This means that all code in this file is considered to be sandboxed in the child process.
function send(message) {
    if (WorkerThreads) {
        if (WorkerThreads.parentPort) {
            WorkerThreads.parentPort.postMessage(message);
        }
        else {
            throw Error('WorkerThreads.parentPort not set!');
        }
    }
    else if (process.send) {
        process.send(message);
        // @ts-ignore global postMessage
    }
    else if (postMessage) {
        // @ts-ignore
        postMessage(message);
    }
    else
        throw Error('process.send and postMessage are undefined!');
}
class ThreadedWorker extends worker_1.Worker {
    sendInstanceMessageToParent(handle, msg, cb) {
        const message = Object.assign(Object.assign({}, msg), {
            messageType: 'instance',
            cmdId: handle.cmdId++,
            instanceId: handle.id
        });
        if (cb) {
            handle.queue[message.cmdId + ''] = {
                // Store an error, just so we can append the original stack later in case there's an error:
                traceError: new Error('Error when calling callback'),
                cb
            };
        }
        send(message);
    }
    sendChildMessageToParent(handle, msg, cb) {
        const message = Object.assign(Object.assign({}, msg), {
            messageType: 'child',
            cmdId: handle.cmdId++
        });
        if (cb) {
            handle.queue[message.cmdId + ''] = {
                // Store an error, just so we can append the original stack later in case there's an error:
                traceError: new Error('Error when calling callback'),
                cb
            };
        }
        send(message);
    }
    killInstance(handle) {
        delete this.instanceHandles[handle.id];
    }
}
function isRunningInAWorkerThread() {
    if ((0, lib_1.nodeSupportsWorkerThreads)()) {
        const workerThreads = (0, lib_1.getWorkerThreads)();
        if (workerThreads) {
            if (!workerThreads.isMainThread) {
                return true;
            }
        }
    }
    return false;
}
if ((0, lib_1.isBrowser)()) {
    // Is running in a web-worker
    const worker = new ThreadedWorker();
    // @ts-ignore global onmessage
    onmessage = (m) => {
        // Received message from parent
        if (m.type === 'message') {
            worker.onMessageFromParent(m.data);
        }
        else {
            console.log('child process: onMessage', m);
        }
    };
}
else if (isRunningInAWorkerThread()) {
    // Is running in a worker-thread
    if (WorkerThreads) {
        const worker = new ThreadedWorker();
        console.log = worker.log;
        console.error = worker.logError;
        if (WorkerThreads.parentPort) {
            WorkerThreads.parentPort.on('message', (m) => {
                // Received message from parent
                worker.onMessageFromParent(m);
            });
        }
        else {
            throw Error('WorkerThreads.parentPort not set!');
        }
    }
    else {
        throw Error('WorkerThreads not available!');
    }
}
else if (process.send) {
    // Is running in a child process
    const worker = new ThreadedWorker();
    console.log = worker.log;
    console.error = worker.logError;
    process.on('message', (m) => {
        // Received message from parent
        worker.onMessageFromParent(m);
    });
}
else {
    throw Error('process.send and onmessage are undefined!');
}
//# sourceMappingURL=threadedclass-worker.js.map