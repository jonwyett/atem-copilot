"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Worker = void 0;
const isRunning = require("is-running");
const lib_1 = require("../shared/lib");
const sharedApi_1 = require("../shared/sharedApi");
/** In a child process, there is running one (1) Worker, which handles the communication with the parent process. */
class Worker {
    constructor() {
        this.childHandler = {
            cmdId: 0,
            queue: {}
        };
        this.instanceHandles = {};
        this.callbacks = {};
        this.remoteFns = {};
        this.disabledMultithreading = false;
        this._parentPid = 0;
        this.log = (...data) => {
            this.sendLog(data);
        };
        this.logError = (...data) => {
            this.sendLog(['Error', ...data]);
        };
    }
    onMessageFromParent(m) {
        // A message was received from Parent
        if (m.messageType === 'instance') {
            let handle = this.instanceHandles[m.instanceId];
            if (!handle && m.cmd !== sharedApi_1.Message.To.Instance.CommandType.INIT) {
                console.log(`Child process: Unknown instanceId: "${m.instanceId}"`);
                return; // fail silently?
            }
            if (!handle) {
                // create temporary handle:
                handle = {
                    id: m.instanceId,
                    cmdId: 0,
                    queue: {},
                    instance: {}
                };
            }
            try {
                this.handleInstanceMessageFromParent(m, handle);
            }
            catch (e) {
                if (m.cmdId) {
                    this.replyInstanceError(handle, m, `Error: ${e.toString()} ${e.stack} thrown in handleInstanceMessageFromParent on instance "${m.instanceId}"`);
                }
                else
                    this.log('Error: ' + e.toString(), e.stack);
            }
        }
        else if (m.messageType === 'child') {
            let handle = this.childHandler;
            try {
                this.handleChildMessageFromParent(m, handle);
            }
            catch (e) {
                if (m.cmdId) {
                    this.replyChildError(handle, m, `Error: ${e.toString()} ${e.stack} thrown in handleChildMessageFromParent on child`);
                }
                else
                    this.log('Error: ' + e.toString(), e.stack);
            }
        }
    }
    decodeArgumentsFromParent(handle, args) {
        // Note: handle.instance could change if this was called for the constructor parameters, so it needs to be loose
        return (0, sharedApi_1.decodeArguments)(() => handle.instance, args, (a) => {
            const callbackId = a.value;
            if (!this.remoteFns[callbackId]) {
                this.remoteFns[callbackId] = ((...args) => {
                    const orgError = new Error();
                    return new Promise((resolve, reject) => {
                        const callbackId = a.value;
                        this.sendCallback(handle, callbackId, args, (err, encodedResult) => {
                            if (err) {
                                const errStack = (0, lib_1.stripStack)((0, lib_1.getErrorStack)(err), [
                                    /[\\/]parent-process[\\/]manager/,
                                    /[\\/]eventemitter3[\\/]index/
                                ]);
                                const orgStack = (orgError.stack + '')
                                    .split('\n')
                                    .slice(2) // Remove the first two lines, since they are internal to ThreadedClass
                                    .join('\n');
                                reject((0, lib_1.combineErrorStacks)(errStack, orgStack));
                                // reject(err)
                            }
                            else {
                                const result = encodedResult ? this.decodeArgumentsFromParent(handle, [encodedResult]) : [encodedResult];
                                resolve(result[0]);
                            }
                        });
                    });
                });
            }
            return this.remoteFns[callbackId];
        });
    }
    encodeArgumentsToParent(instance, args) {
        return (0, sharedApi_1.encodeArguments)(instance, this.callbacks, args, this.disabledMultithreading);
    }
    replyToInstanceMessage(handle, messageToReplyTo, reply) {
        this.sendInstanceReplyToParent(handle, messageToReplyTo.cmdId, undefined, reply);
    }
    replyToChildMessage(handle, messageToReplyTo, reply) {
        this.sendChildReplyToParent(handle, messageToReplyTo.cmdId, undefined, reply);
    }
    replyInstanceError(handle, messageToReplyTo, error) {
        this.sendInstanceReplyToParent(handle, messageToReplyTo.cmdId, error);
    }
    replyChildError(handle, messageToReplyTo, error) {
        this.sendChildReplyToParent(handle, messageToReplyTo.cmdId, error);
    }
    sendInstanceReplyToParent(handle, replyTo, error, reply) {
        let msg = {
            cmd: sharedApi_1.Message.From.Instance.CommandType.REPLY,
            replyTo: replyTo,
            error: error ? (error.stack || error).toString() : error,
            reply: reply
        };
        this.sendInstanceMessageToParent(handle, msg);
    }
    sendChildReplyToParent(handle, replyTo, error, reply) {
        let msg = {
            cmd: sharedApi_1.Message.From.Child.CommandType.REPLY,
            replyTo: replyTo,
            error: error ? (error.stack || error).toString() : error,
            reply: reply
        };
        this.sendChildMessageToParent(handle, msg);
    }
    sendLog(log) {
        let msg = {
            cmd: sharedApi_1.Message.From.Child.CommandType.LOG,
            log: log
        };
        this.sendChildMessageToParent(this.childHandler, msg);
    }
    sendCallback(handle, callbackId, args, cb) {
        let msg = {
            cmd: sharedApi_1.Message.From.Instance.CommandType.CALLBACK,
            callbackId: callbackId,
            args: args
        };
        this.sendInstanceMessageToParent(handle, msg, cb);
    }
    getAllProperties(obj) {
        let props = [];
        do {
            props = props.concat(Object.getOwnPropertyNames(obj));
            obj = Object.getPrototypeOf(obj);
        } while (obj);
        return props;
    }
    handleInstanceMessageFromParent(m, handle) {
        const instance = handle.instance;
        if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.INIT) {
            // This is the initial message sent from the parent process upon initialization.
            const msg = m;
            this._config = m.config;
            this._parentPid = m.parentPid;
            let pModuleClass;
            // Load in the class:
            if ((0, lib_1.isBrowser)()) {
                pModuleClass = new Promise((resolve, reject) => {
                    // @ts-ignore
                    let oReq = new XMLHttpRequest();
                    oReq.open('GET', msg.modulePath, true);
                    // oReq.responseType = 'blob'
                    oReq.onload = () => {
                        if (oReq.response) {
                            resolve(oReq.response);
                        }
                        else {
                            reject(Error(`Bad reply from ${msg.modulePath} in instance ${handle.id}`));
                        }
                    };
                    oReq.send();
                })
                    .then((bodyString) => {
                    // This is a terrible hack, I'm ashamed of myself.
                    // Better solutions are very much appreciated.
                    // tslint:disable-next-line:no-var-keyword
                    var f = null;
                    let fcn = `
						f = function() {
							${bodyString}
							;
							return ${msg.exportName}
						}
					`;
                    // tslint:disable-next-line:no-eval
                    let moduleClass = eval(fcn)();
                    f = f;
                    if (!moduleClass) {
                        throw Error(`${msg.exportName} not found in ${msg.modulePath}`);
                    }
                    return moduleClass;
                });
            }
            else {
                pModuleClass = Promise.resolve(require(msg.modulePath))
                    .then((module) => {
                    return module[msg.exportName];
                });
            }
            pModuleClass
                .then((moduleClass) => {
                if (!moduleClass) {
                    return Promise.reject('Failed to find class');
                }
                const handle = {
                    id: msg.instanceId,
                    cmdId: 0,
                    queue: {},
                    instance: null // Note: This is dangerous, but gets set right after.
                };
                const decodedArgs = this.decodeArgumentsFromParent(handle, msg.args);
                handle.instance = ((...args) => {
                    return new moduleClass(...args);
                }).apply(null, decodedArgs);
                this.instanceHandles[handle.id] = handle;
                const instance = handle.instance;
                const allProps = this.getAllProperties(instance);
                const props = [];
                allProps.forEach((prop) => {
                    if ([
                        'constructor',
                        '__defineGetter__',
                        '__defineSetter__',
                        'hasOwnProperty',
                        '__lookupGetter__',
                        '__lookupSetter__',
                        'isPrototypeOf',
                        'propertyIsEnumerable',
                        'toString',
                        'valueOf',
                        '__proto__',
                        'toLocaleString'
                    ].indexOf(prop) !== -1)
                        return;
                    let descriptor = Object.getOwnPropertyDescriptor(instance, prop);
                    let inProto = 0;
                    let proto = instance.__proto__;
                    while (!descriptor) {
                        if (!proto)
                            break;
                        descriptor = Object.getOwnPropertyDescriptor(proto, prop);
                        inProto++;
                        proto = proto.__proto__;
                    }
                    if (!descriptor)
                        descriptor = {};
                    let descr = {
                        // configurable:	!!descriptor.configurable,
                        inProto: inProto,
                        enumerable: !!descriptor.enumerable,
                        writable: !!descriptor.writable,
                        get: !!descriptor.get,
                        set: !!descriptor.set,
                        readable: !!(!descriptor.get && !descriptor.get) // if no getter or setter, ie an ordinary property
                    };
                    if (typeof instance[prop] === 'function') {
                        props.push({
                            key: prop,
                            type: sharedApi_1.InitPropType.FUNCTION,
                            descriptor: descr
                        });
                    }
                    else {
                        props.push({
                            key: prop,
                            type: sharedApi_1.InitPropType.VALUE,
                            descriptor: descr
                        });
                    }
                });
                this.replyToInstanceMessage(handle, msg, props);
                return;
            })
                .catch((err) => {
                const errStack = (0, lib_1.stripStack)(err.stack || err.toString(), [
                    /onMessageFromParent/,
                    /threadedclass-worker/
                ]);
                let errorResponse = `${errStack}\n executing constructor of instance "${m.instanceId}"`;
                this.replyInstanceError(handle, msg, errorResponse);
                return;
            });
            if (!m.config.disableMultithreading && !(0, lib_1.nodeSupportsWorkerThreads)()) {
                this.startOrphanMonitoring();
            }
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.PING) {
            // This is a message from the parent process. It's just a ping, used to check if this instance is alive.
            this.replyToInstanceMessage(handle, m, null);
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.REPLY) {
            // A reply to an earlier message.
            const msg = m;
            let cb = handle.queue[msg.replyTo + ''];
            if (!cb)
                throw Error(`cmdId "${msg.cmdId}" not found in instance ${m.instanceId}!`);
            if (msg.error) {
                cb.cb(msg.error);
            }
            else {
                cb.cb(null, msg.reply);
            }
            delete handle.queue[msg.replyTo + ''];
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.FUNCTION) {
            // A function/method has been called by the parent
            let msg = m;
            const fixedArgs = this.decodeArgumentsFromParent(handle, msg.args);
            let p;
            try {
                if (typeof instance[msg.fcn] === 'function') {
                    p = instance[msg.fcn](...fixedArgs);
                }
                else {
                    // in case instance[msg.fcn] does not exist, it will simply resolve to undefined
                    p = instance[msg.fcn];
                }
            }
            catch (error) {
                p = Promise.reject(error);
            }
            Promise.resolve(p)
                .then((result) => {
                const encodedResult = this.encodeArgumentsToParent(instance, [result]);
                this.replyToInstanceMessage(handle, msg, encodedResult[0]);
            })
                .catch((err) => {
                const errStack = (0, lib_1.stripStack)(err.stack || err.toString(), [
                    /onMessageFromParent/,
                    /threadedclass-worker/
                ]);
                let errorResponse = `${errStack}\n executing function "${msg.fcn}" of instance "${m.instanceId}"`;
                this.replyInstanceError(handle, msg, errorResponse);
            });
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.SET) {
            // A setter has been called by the parent
            let msg = m;
            const fixedValue = this.decodeArgumentsFromParent(handle, [msg.value])[0];
            instance[msg.property] = fixedValue;
            const encodedResult = this.encodeArgumentsToParent(instance, [fixedValue]);
            this.replyToInstanceMessage(handle, msg, encodedResult[0]);
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.KILL) {
            // A Kill-command has been sent by the parent.
            let msg = m;
            // kill off instance
            this.killInstance(handle);
            this.replyToInstanceMessage(handle, msg, null);
        }
        else if (m.cmd === sharedApi_1.Message.To.Instance.CommandType.CALLBACK) {
            // A callback has been called by the parent.
            // A "callback" is a function that has been sent to the parent process from the child instance.
            let msg = m;
            let callback = this.callbacks[msg.callbackId];
            if (callback) {
                try {
                    Promise.resolve(callback(...msg.args))
                        .then((result) => {
                        const encodedResult = this.encodeArgumentsToParent(instance, [result]);
                        this.replyToInstanceMessage(handle, msg, encodedResult[0]);
                    })
                        .catch((err) => {
                        let errorResponse = (err.stack || err.toString()) + `\n executing callback of instance "${m.instanceId}"`;
                        this.replyInstanceError(handle, msg, errorResponse);
                    });
                }
                catch (err) {
                    let errorResponse = (err.stack || err.toString()) + `\n executing (outer) callback of instance "${m.instanceId}"`;
                    this.replyInstanceError(handle, msg, errorResponse);
                }
            }
            else {
                this.replyInstanceError(handle, msg, `Callback "${msg.callbackId}" not found on instance "${m.instanceId}"`);
            }
        }
        else {
            (0, lib_1.assertNever)(m);
        }
    }
    handleChildMessageFromParent(m, handle) {
        if (m.cmd === sharedApi_1.Message.To.Child.CommandType.GET_MEM_USAGE) {
            let memUsage = (process ?
                process.memoryUsage() :
                // @ts-ignore web-worker global window
                window ?
                    // @ts-ignore web-worker global window
                    window.performance.memory :
                    { error: 'N/A' });
            const encodedResult = this.encodeArgumentsToParent({}, [memUsage])[0];
            this.replyToChildMessage(handle, m, encodedResult);
        }
    }
    startOrphanMonitoring() {
        if (this._config) {
            const pingTime = 5000;
            setInterval(() => {
                if (this._parentPid && !isRunning(this._parentPid)) {
                    console.log(`Parent pid ${this._parentPid} missing, exiting process!`);
                    setTimeout(() => {
                        process.exit(27);
                    }, 100);
                }
            }, pingTime);
        }
    }
}
exports.Worker = Worker;
//# sourceMappingURL=worker.js.map